import{_ as e,c as l,o as r,b as d,d as a}from"./app.e35a2696.js";const n='{"title":"0902","description":"","frontmatter":{},"headers":[{"level":2,"title":"工作","slug":"工作"},{"level":2,"title":"TODOS","slug":"todos"}],"relativePath":"record/09/0902.md","lastUpdated":1636731103223}',t={},u=[d("h1",{id:"_0902",tabindex:"-1"},[a("0902 "),d("a",{class:"header-anchor",href:"#_0902","aria-hidden":"true"},"#")],-1),d("p",null,[d("img",{src:"/study-everyday/assets/0902.5d52c198.jpg",alt:""})],-1),d("h2",{id:"工作",tabindex:"-1"},[a("工作 "),d("a",{class:"header-anchor",href:"#工作","aria-hidden":"true"},"#")],-1),d("ul",null,[d("li",null,"重复 render 的bug：昨天发现个重复 render 的bug，现象是，Table 组件的勾选，会导致里面的数据重复 render，从而闪屏；如果只有文字，倒是看不出来，因为里面有图片，所以闪屏问题很明显；"),d("li",null,"排查原因：一开始以为是 勾选操作改变了 dataSource，检查了一下，并没有。组件内部勾选，只改变了 selectedKeys，没改变其他的东西；而且内部的子组件都使用了 memo(Com, () => true) 进行强制缓存；那么除了 数据变化，还有什么东西可能会导致重复 render 呢？")],-1),d("p",null,[a("答案："),d("code",null,"key"),a(" ，表格内部的 render 是自定义的某个子组件，里面涉及了遍历，map 循环的外层元素需要加 key，我使用的是 "),d("code",null,"uuid()"),a("，因此每次状态变更都会生成新的 key；因此 diff 算法过程中会认为这是一个新的组件，继而全量替换掉，继而重复 render；")],-1),d("p",null,"因此，以后 这种 key 不能乱用 uuid；如果要用，则 2 种方案：",-1),d("ul",null,[d("li",null,"数据源的起始端加 uuid，从而保证后面状态变更的 id 不会再变了；"),d("li",null,"直接使用 map 的 index 作为 key；但是某些场景（排序，删除节点）不能使用 index 作为 key。")],-1),d("p",null,"参考资料：",-1),d("ul",null,[d("li",null,[d("a",{href:"https://juejin.cn/post/6844904133430870024",target:"_blank",rel:"noopener noreferrer"},"轻松理解为什么不用Index作为key")])],-1),d("h2",{id:"todos",tabindex:"-1"},[a("TODOS "),d("a",{class:"header-anchor",href:"#todos","aria-hidden":"true"},"#")],-1)];var i=e(t,[["render",function(e,d,a,n,t,i){return r(),l("div",null,u)}]]);export{n as __pageData,i as default};
