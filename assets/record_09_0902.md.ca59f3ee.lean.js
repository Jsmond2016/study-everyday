import{o as e,c as l,b as r,d}from"./app.f2954a1b.js";const n='{"title":"0902","description":"","frontmatter":{},"headers":[{"level":2,"title":"工作","slug":"工作"},{"level":2,"title":"TODOS","slug":"todos"}],"relativePath":"record/09/0902.md","lastUpdated":1630975392406}',a={},t=r("h1",{id:"_0902"},[r("a",{class:"header-anchor",href:"#_0902","aria-hidden":"true"},"#"),d(" 0902")],-1),u=r("p",null,[r("img",{src:"/study-everyday/assets/0902.5d52c198.jpg",alt:""})],-1),i=r("h2",{id:"工作"},[r("a",{class:"header-anchor",href:"#工作","aria-hidden":"true"},"#"),d(" 工作")],-1),s=r("ul",null,[r("li",null,"重复 render 的bug：昨天发现个重复 render 的bug，现象是，Table 组件的勾选，会导致里面的数据重复 render，从而闪屏；如果只有文字，倒是看不出来，因为里面有图片，所以闪屏问题很明显；"),r("li",null,"排查原因：一开始以为是 勾选操作改变了 dataSource，检查了一下，并没有。组件内部勾选，只改变了 selectedKeys，没改变其他的东西；而且内部的子组件都使用了 memo(Com, () => true) 进行强制缓存；那么除了 数据变化，还有什么东西可能会导致重复 render 呢？")],-1),o=r("p",null,[d("答案："),r("code",null,"key"),d(" ，表格内部的 render 是自定义的某个子组件，里面涉及了遍历，map 循环的外层元素需要加 key，我使用的是 "),r("code",null,"uuid()"),d("，因此每次状态变更都会生成新的 key；因此 diff 算法过程中会认为这是一个新的组件，继而全量替换掉，继而重复 render；")],-1),h=r("p",null,"因此，以后 这种 key 不能乱用 uuid；如果要用，则 2 种方案：",-1),c=r("ul",null,[r("li",null,"数据源的起始端加 uuid，从而保证后面状态变更的 id 不会再变了；"),r("li",null,"直接使用 map 的 index 作为 key；但是某些场景（排序，删除节点）不能使用 index 作为 key。")],-1),p=r("p",null,"参考资料：",-1),f=r("ul",null,[r("li",null,[r("a",{href:"https://juejin.cn/post/6844904133430870024",target:"_blank",rel:"noopener noreferrer"},"轻松理解为什么不用Index作为key")])],-1),y=r("h2",{id:"todos"},[r("a",{class:"header-anchor",href:"#todos","aria-hidden":"true"},"#"),d(" TODOS")],-1);a.render=function(r,d,n,a,m,k){return e(),l("div",null,[t,u,i,s,o,h,c,p,f,y])};export default a;export{n as __pageData};
