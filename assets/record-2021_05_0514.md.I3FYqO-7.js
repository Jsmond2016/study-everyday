import{_ as o,c as t,a2 as l,o as r}from"./chunks/framework.ek9jOonm.js";const a="/study-everyday/assets/antd-01.Cp9XOGb2.png",c="/study-everyday/assets/antd-02.CqnU404D.png",h=JSON.parse('{"title":"0514","description":"","frontmatter":{},"headers":[],"relativePath":"record-2021/05/0514.md","filePath":"record-2021/05/0514.md"}'),d={name:"record-2021/05/0514.md"};function i(n,e,s,m,p,u){return r(),t("div",null,e[0]||(e[0]=[l('<h1 id="_0514" tabindex="-1">0514 <a class="header-anchor" href="#_0514" aria-label="Permalink to &quot;0514&quot;">​</a></h1><p><img src="http://h2.ioliu.cn/bing/SaltCones_ZH-CN4825397608_1920x1080.jpg" alt=""></p><h2 id="工作" tabindex="-1">工作 <a class="header-anchor" href="#工作" aria-label="Permalink to &quot;工作&quot;">​</a></h2><ul><li><p>后台开发：详情页，记录个 <strong>问题</strong>：</p><ul><li><code>Form.Item</code> 里面只能放一个子组件，如果里面多包裹了其他组件（例如 <code>Tooltip</code>），此时使用 <code>form.validateFields().then(values =&gt; {})</code> 就拿不到表单的值，包裹在外面的话，只能使用 <code>css</code> 处理位置偏差问题。</li><li>实际上，文档上是有这种场景的解决办法的，只是我没注意看：<a href="https://ant.design/components/form-cn/" target="_blank" rel="noreferrer">Form表单</a></li></ul><p><img src="'+a+'" alt=""></p><p><img src="'+c+'" alt=""></p><ul><li>主要几个点(绿色箭头部分)： <ul><li>使用 <code>Form.Item</code> 进行包裹，<code>label</code> 移到外层的 <code>Form.Item</code> 里</li><li>使用 <code>Space</code> 控制间距（非必须）</li><li>使用 <code>noStyle</code> 控制 <code>Form.Item</code> 的样式为<strong>无样式</strong></li></ul></li></ul><p>具体做法如上图：使用 <code>Form.Item</code> 包裹 <code>Form.Item</code> 即可实现。但是会带来个问题，因为嵌套了 <code>Form.Item</code> ，高度会变大，还要处理样式问题？实际上容易忽略一个细节：<code>noStyle</code> ，具体看引入官网描述：</p><blockquote><p>这里演示 <code>Form.Item</code> 内有多个元素的使用方式。<code>&lt;Form.Item name=&quot;field&quot; /&gt;</code> 只会对它的直接子元素绑定表单功能，例如直接包裹了 <code>Input/Select</code>。如果控件前后还有一些文案或样式装点，或者一个表单项内有多个控件，你可以使用内嵌的 <code>Form.Item</code> 完成。你可以给 <code>Form.Item</code> 自定义 <code>style</code> 进行内联布局，或者添加 <code>noStyle</code> 作为纯粹的无样式绑定组件（类似 3.x 中的 <code>getFieldDecorator</code>）</p></blockquote></li><li><p><strong>迭代反思</strong>：水印需求上线了，虽然验收，但还是有不足。</p><ul><li>第一次做这种实现，<strong>技术研究和讨论不够</strong>（和大佬讨论，以及可能要实现的细节），不能盲目自信，承认别人比你优秀！</li><li>对于这种第一次做的/自己没有把握的需求，<strong>需要进行阶段性确认</strong>，每做出一定效果和 UI 和产品对一下是否满意，边做边改，而不是到上线了再改。</li><li>注意<strong>边界问题</strong>：例如 字体最小值，水印最小的大小（宽高）</li><li>跟着规范走：前端需要详细<strong>阅读了解 UI 的设计规范原则</strong>，什么样的页面长什么样，避免返工</li><li><strong>需求评审阶段需要特别细心，勇敢的和产品撕逼（提出不合理地方）</strong>，把问题确认在前面，最好不要做到了某个地方再找产品说这里那里的实现方式不合适等。</li></ul></li></ul><h2 id="好文推荐" tabindex="-1">好文推荐 <a class="header-anchor" href="#好文推荐" aria-label="Permalink to &quot;好文推荐&quot;">​</a></h2><ul><li><a href="https://blog.csdn.net/weixin_41723305/article/details/109589659" target="_blank" rel="noreferrer">浏览器对get请求缓存问题</a> 同事问关于代码中请求拦截器，看到关于 <code>get</code> 请求加时间戳的代码。主要是为了处理在 <code>IE</code> 才有的缓存请求问题，现阶段谷歌和火狐没有这种问题。</li><li><a href="https://zhuanlan.zhihu.com/p/348506627" target="_blank" rel="noreferrer">解决IE浏览器get请求缓存的问题</a> 这里介绍了3种方式处理请求缓存问题，除了上面 时间戳方式，还有后端设置 <code>cache-control</code> ，设置 <code>&lt;meta http-equiv=&quot;&quot;&gt;</code> 禁用缓存的方式解决。</li></ul><h2 id="todos" tabindex="-1">TODOS <a class="header-anchor" href="#todos" aria-label="Permalink to &quot;TODOS&quot;">​</a></h2><ul><li>图片问题整理总结：水印，相机唤醒，图片压缩等</li><li>图片压缩资料整理</li><li>水印图2（高密度的水印），尝试动手实现</li></ul>',8)]))}const _=o(d,[["render",i]]);export{h as __pageData,_ as default};
