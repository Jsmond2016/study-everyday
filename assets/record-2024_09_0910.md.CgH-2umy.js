import{_ as a,c as i,o as s,a3 as e}from"./chunks/framework.B1tUqxYT.js";const m=JSON.parse('{"title":"0910 今日总结","description":"","frontmatter":{},"headers":[],"relativePath":"record-2024/09/0910.md","filePath":"record-2024/09/0910.md"}'),t={name:"record-2024/09/0910.md"},l=e(`<h1 id="_0910-今日总结" tabindex="-1">0910 今日总结 <a class="header-anchor" href="#_0910-今日总结" aria-label="Permalink to &quot;0910 今日总结&quot;">​</a></h1><h2 id="好文推荐" tabindex="-1">好文推荐 <a class="header-anchor" href="#好文推荐" aria-label="Permalink to &quot;好文推荐&quot;">​</a></h2><blockquote><p>有感好文，专题好文</p></blockquote><h3 id="top3" tabindex="-1">TOP3 <a class="header-anchor" href="#top3" aria-label="Permalink to &quot;TOP3&quot;">​</a></h3><ul><li><a href="https://juejin.cn/post/7381742187703812130" target="_blank" rel="noreferrer">让你的TypeScript代码更优雅，这10个特性你需要了解下TypeScript不仅仅是JavaScript的类型超集 - 掘金</a></li><li><a href="https://segmentfault.com/a/1190000006047872" target="_blank" rel="noreferrer">html - CSS display 属性详解 - zhanfang - SegmentFault 思否</a></li></ul><h3 id="英文推荐" tabindex="-1">英文推荐 <a class="header-anchor" href="#英文推荐" aria-label="Permalink to &quot;英文推荐&quot;">​</a></h3><ul><li><a href="https://github.com/char0n/ramda-adjunct" target="_blank" rel="noreferrer">char0n/ramda-adjunct: Ramda Adjunct is the most popular and most comprehensive set of functional utilities for use with Ramda, providing a variety of useful, well tested functions with excellent documentation.</a> 这个是函数式编程 ramda 中的进阶库，补充了一些内容；</li><li><a href="https://github.com/tommmyy/ramda-extension" target="_blank" rel="noreferrer">tommmyy/ramda-extension: 🤘Utility library for functional JavaScript. With ❤️ to Ramda.</a></li><li><a href="https://ramda-extension.web.app/docs/#mapOver" target="_blank" rel="noreferrer">Ramda extension Documentation</a></li><li><a href="https://github.com/selfrefactor/rambda" target="_blank" rel="noreferrer">selfrefactor/rambda: Faster and smaller alternative to Ramda</a></li></ul><h3 id="其他好文" tabindex="-1">其他好文 <a class="header-anchor" href="#其他好文" aria-label="Permalink to &quot;其他好文&quot;">​</a></h3><ul><li><a href="https://juejin.cn/post/6844903826173100046#heading-3" target="_blank" rel="noreferrer">JavaScript 记忆（Memoization）函数记忆函数（Memoization）是一种用于长递归或长迭代操作 - 掘金</a></li></ul><h2 id="项目-博客推荐" tabindex="-1">项目/博客推荐 <a class="header-anchor" href="#项目-博客推荐" aria-label="Permalink to &quot;项目/博客推荐&quot;">​</a></h2><blockquote><p>值得学习 作者/项目/工具等</p></blockquote><h3 id="博客" tabindex="-1">博客 <a class="header-anchor" href="#博客" aria-label="Permalink to &quot;博客&quot;">​</a></h3><h3 id="项目" tabindex="-1">项目 <a class="header-anchor" href="#项目" aria-label="Permalink to &quot;项目&quot;">​</a></h3><ul><li><a href="https://github.com/iamdarcy/hioshop-server/tree/master" target="_blank" rel="noreferrer">iamdarcy/hioshop-server: 海风小店，开源商城，微信小程序商城服务器端</a></li></ul><h3 id="工具-前端库" tabindex="-1">工具 &amp; 前端库 <a class="header-anchor" href="#工具-前端库" aria-label="Permalink to &quot;工具 &amp; 前端库&quot;">​</a></h3><ul><li><a href="https://daojishi.fun/" target="_blank" rel="noreferrer">改革后法定延迟退休年龄计算器 &amp; 退休倒计时 | 用有趣对抗时间</a></li><li><a href="https://juejin.cn/post/7392501157778260008" target="_blank" rel="noreferrer">使用ACME申请SSL证书- 掘金</a></li><li><a href="https://www.yuque.com/flipped-aurora/gqbcfk/hivgd5#FrN0U" target="_blank" rel="noreferrer">Mac工具分享</a></li></ul><h2 id="求职就业等" tabindex="-1">求职就业等 <a class="header-anchor" href="#求职就业等" aria-label="Permalink to &quot;求职就业等&quot;">​</a></h2><ul><li><a href="https://fast.v2ex.com/t/1068420" target="_blank" rel="noreferrer">[长沙-外企] 招聘 React 前端工程师 - V2EX</a> 这个是 V 站的帖子，题主在这里 po 的公司，看了下，待遇还是可以的，至少在长沙还是OK的；不过公司的业务感觉还是有点风险，摘录1条评论：关键词，【赌场】</li></ul><blockquote><p>EveryMatrix 是一家领先的 B2B SaaS 提供商，提供 iGaming 软件、内容和服务。我们为全球 200 家客户提供赌场、体育博彩、平台和支付以及联盟管理。该公司盈利良好，年收入超过 1 亿欧元，在欧洲、亚洲和美国的 10 个国家设有办事处，拥有 1000 名员工。EveryMatrix 成立于 2008 年，目前仍是一家由创始人拥有的私营公司。 在国内有可能吃牢饭。但是一说长沙我就知道没问题。不然你以为法外之地称号怎么来的</p></blockquote><ul><li><a href="https://www.v2ex.com/t/1073230#reply16" target="_blank" rel="noreferrer">86 年 38 岁老程序员求职,求建议,方向 - V2EX</a></li></ul><h2 id="讨论" tabindex="-1">讨论 <a class="header-anchor" href="#讨论" aria-label="Permalink to &quot;讨论&quot;">​</a></h2><ul><li><a href="https://www.npmjs.com/package/memoizee" target="_blank" rel="noreferrer">memoizee - npm</a> 缓存函数，其实在 react 中有类似的, useMemo, useCallback, 或者 ahooks 中的 useMemorizedFn ...</li></ul><p>我们问问 gpt：</p><div class="tip custom-block"><p class="custom-block-title">评价一下 Memoizee 这个前端库有什么特点，对比 react 的 useCallback, useMemo 等，为什么要使用它，如何使用？</p><hr><p>Memoizee 特点</p><p>Memoizee 是一个 JavaScript 的高性能记忆化（memoization）库，主要用于缓存函数的输出，以提高性能。它的主要特点包括：</p><ul><li>灵活性：支持多种缓存策略，可以根据需求自定义缓存的方式。</li><li>高效性：使用高效的算法来存储和检索缓存数据，适合性能要求高的应用。</li><li>多参数支持：能够处理多个参数的函数，而不仅仅是单一参数。</li><li>失效机制：支持缓存失效的策略，可以设置过期时间或手动清除缓存。</li><li>自定义序列化：允许用户自定义缓存键的生成方式，以适应复杂的参数类型。</li></ul><p>对比 React 的 useCallback 和 useMemo</p><p>useCallback 和 useMemo 是 React 提供的钩子，用于优化组件性能，减少不必要的重新渲染。</p><p>useCallback 用于缓存函数的引用，避免在每次渲染时重新创建函数。 useMemo 用于缓存计算结果，避免在每次渲染时重新计算。</p><p>主要区别：</p><ul><li>作用范围：Memoizee 是一个通用的函数缓存库，适用于任何 JavaScript 函数，而 useCallback 和 useMemo 仅限于 React 组件内。</li><li>灵活性：Memoizee 提供了更丰富的配置选项，如缓存策略和失效机制，而 useCallback 和 useMemo 的使用相对简单，主要是为了优化 React 渲染。</li></ul><p>为什么使用 Memoizee</p><ul><li>提高性能：在需要频繁调用的复杂计算函数中，使用 Memoizee 可以显著减少计算时间。</li><li>跨环境使用：可以在任意 JavaScript 环境中使用，而不仅限于 React。</li><li>灵活的缓存管理：支持多种缓存策略，可以根据具体需求进行调整。</li></ul><p>如何使用 Memoizee</p><p>下面是一个简单的使用示例：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> memoize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;memoizee&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个记忆化函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fibonacci</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> memoize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibonacci</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibonacci</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用记忆化函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fibonacci</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 55</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fibonacci</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从缓存中获取，计算更快</span></span></code></pre></div><p>总结</p><p>Memoizee 是一个强大的工具，适合需要高性能计算的场景。与 React 的 useCallback 和 useMemo 相比，它提供了更广泛的应用场景和灵活的配置选项，适合在多种 JavaScript 环境中使用。</p></div>`,24),n=[l];function r(h,p,k,o,c,d){return s(),i("div",null,n)}const E=a(t,[["render",r]]);export{m as __pageData,E as default};
