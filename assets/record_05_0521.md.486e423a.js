import{o as e,c as r,a as l}from"./app.63e8f2c2.js";const a='{"title":"0513","description":"","frontmatter":{},"headers":[{"level":2,"title":"工作","slug":"工作"},{"level":2,"title":"好文推荐","slug":"好文推荐"},{"level":2,"title":"项目推荐","slug":"项目推荐"},{"level":2,"title":"反思","slug":"反思"},{"level":2,"title":"明日计划","slug":"明日计划"},{"level":2,"title":"TODOS","slug":"todos"}],"relativePath":"record/05/0521.md","lastUpdated":1625239030342}',o={},d=l('<h1 id="_0513"><a class="header-anchor" href="#_0513" aria-hidden="true">#</a> 0513</h1><h2 id="工作"><a class="header-anchor" href="#工作" aria-hidden="true">#</a> 工作</h2><ul><li>使用 AntDesing 遇到的问题：如何实现多个 <code>Form.Item</code> 内容联动，即输入框A的值变化后，B也随之变化 <ul><li>往期经验：在 <code>3.x</code> 版本中，使用方式是 <code>getFieldValue(&#39;A&#39;)</code> 即可动态拿到 A 的值，但是当前版本是 <code>4.x</code> ，<code>Form</code> 组件做了性能优化，组件值变化不会重新 render</li><li>猜测：肯定会提供这种 API 的，因为这是一种很常见的表单操作</li><li>发现：<code>shouldUpdate: (prevValue, curValue) =&gt; boolean</code> 自定义字段更新逻辑，附带用法：<a href="https://ant.design/components/form-cn/#shouldUpdate" target="_blank" rel="noopener noreferrer">shouldUpdate</a></li><li>注意细节：<code>shouldUpdate</code> 是一个判断条件，可以拿到表单新旧的所有值，因此可以对比。其次，<code>Form.Item</code> 里面的内容，必须要是一个回调函数，普通函数式不行的。这里可以理解为，对 <code>Form.Item</code> 组件的值进行监听，触发的是一个回调函数。</li></ul></li></ul><h2 id="好文推荐"><a class="header-anchor" href="#好文推荐" aria-hidden="true">#</a> 好文推荐</h2><ul><li><a href="https://mp.weixin.qq.com/s/7NxQMtolD3UL5qDBsDkIWw" target="_blank" rel="noopener noreferrer">前端水印实现方案</a></li><li><a href="https://mp.weixin.qq.com/s/SXIVJ3br8dTLu_CZgNy_8A" target="_blank" rel="noopener noreferrer">一文看懂Chrome浏览器工作原理</a> 学习浏览器的进程，线程，渲染流程</li><li><a href="https://mp.weixin.qq.com/s/FMUA4qnQigI7Eo_PrUg0Sw" target="_blank" rel="noopener noreferrer">实战：Express 模拟 CSRF 攻击</a> 学习了解 CSRF 攻击流程，CSRF 模拟攻击，CSRF 防范方法</li></ul><h2 id="项目推荐"><a class="header-anchor" href="#项目推荐" aria-hidden="true">#</a> 项目推荐</h2><h2 id="反思"><a class="header-anchor" href="#反思" aria-hidden="true">#</a> 反思</h2><ul><li>今天比较有成就感的事情，就是发现了公司设计规范的不足，然后和 UI 小哥 argue，按照在上家公司的开发习惯，关于查询页页面原型，提出我的看法。</li><li>毕竟仅仅是 一个查询页，我觉得没有必要展现各种表单元素然后一个个 disabled 掉，如果表单组件联动，业务一旦复杂度上升，那么代码维护难度就会很大。</li><li>所以建议 <strong>对查询页单独设一个页面，纯文字展示</strong>；虽然多了页面，但是开发难度也简单，参照编辑页，去掉所有操作项，只留下查询和展示</li><li>虽然多花了2个多小时开发，但是感觉开了这个先例和规范，以后开发舒适度会好很多。</li></ul><h2 id="明日计划"><a class="header-anchor" href="#明日计划" aria-hidden="true">#</a> 明日计划</h2><ul><li>假期休息，反思自己学习的不足</li></ul><h2 id="todos"><a class="header-anchor" href="#todos" aria-hidden="true">#</a> TODOS</h2>',11);o.render=function(l,a,o,i,t,h){return e(),r("div",null,[d])};export default o;export{a as __pageData};
