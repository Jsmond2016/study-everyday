import{_ as r,c as a,a2 as t,o as l}from"./chunks/framework.ek9jOonm.js";const o="/study-everyday/assets/fcp.Ch-vKzG3.png",d=JSON.parse('{"title":"1112","description":"","frontmatter":{},"headers":[],"relativePath":"record-2021/11/1112.md","filePath":"record-2021/11/1112.md"}'),n={name:"record-2021/11/1112.md"};function i(h,e,p,s,c,u){return l(),a("div",null,e[0]||(e[0]=[t('<h1 id="_1112" tabindex="-1">1112 <a class="header-anchor" href="#_1112" aria-label="Permalink to &quot;1112&quot;">​</a></h1><p><img src="http://h2.ioliu.cn/bing/LandsEndSunset_ZH-CN0737794484_1920x1080.jpg" alt=""></p><h2 id="工作" tabindex="-1">工作 <a class="header-anchor" href="#工作" aria-label="Permalink to &quot;工作&quot;">​</a></h2><ul><li>如何分析页面的性能？有哪些性能指标？如何做性能优化？</li></ul><p>什么是 <code>FCP, FP, LCP, DCP, TTI, TBT...</code> ???</p><p>今天刷网页偶现这个问题，自己对这方面是不了解的，不过隐约知道可以使用浏览器工具 performance, lighthouse 分析；</p><p><img src="'+o+'" alt=""></p><p><strong>查阅相关资料：</strong></p><ul><li><a href="https://blog.csdn.net/c_kite/article/details/104237256" target="_blank" rel="noreferrer">Chrome Performance 常见名词解释 (FP, FCP, LCP, DCL, FMP, TTI, TBT, FID, CLS)</a></li><li><a href="https://juejin.cn/post/7016922364185149477" target="_blank" rel="noreferrer">前端性能优化之Lighthouse实战 “点对点”优化</a></li><li><a href="https://juejin.cn/post/6973567030528065573" target="_blank" rel="noreferrer">使用 Performance API 获取页面性能</a></li><li><a href="https://juejin.cn/post/6963620408742379533" target="_blank" rel="noreferrer">【1w字】浏览器的V8引擎到底是什么？</a></li></ul><p><strong>拓展知识：</strong></p><ul><li><a href="https://blog.csdn.net/weixin_42071117/article/details/104595132" target="_blank" rel="noreferrer">浅析 Chrome 浏览器的多进程架构</a></li><li><a href="https://juejin.cn/post/6844904090439254030" target="_blank" rel="noreferrer">Chrome架构：仅仅打开一个页面，为什么会有 5 个进程？</a></li></ul><p>1.浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p><p>2.网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，后来成为一个单独的进程。</p><p>3.渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程（浏览上下文组和同一站点对此有影响，后续会介绍）。出于安全考虑，渲染进程都是运行在安全沙箱模式下。</p><p>4.插件进程：在沙箱模式中进行，将插件单独放在一个进程中，是为了保证插件的崩溃不会对浏览器和页面造成影响。</p><p>5.GPU进程：GPU 的使用初始是为了实现 3D CSS 的效果。随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后 Chrome 在其多进程架构上也引入了 GPU 进程。</p><h2 id="今日算法" tabindex="-1">今日算法 <a class="header-anchor" href="#今日算法" aria-label="Permalink to &quot;今日算法&quot;">​</a></h2><p>今日学习：</p><p>今日复习：</p><h2 id="温故知新" tabindex="-1">温故知新 <a class="header-anchor" href="#温故知新" aria-label="Permalink to &quot;温故知新&quot;">​</a></h2><blockquote><p>防抖节流等各种手写，http和网络，浏览器原理，性能优化，Webpack</p></blockquote><h2 id="好文推荐" tabindex="-1">好文推荐 <a class="header-anchor" href="#好文推荐" aria-label="Permalink to &quot;好文推荐&quot;">​</a></h2><blockquote><p>有感好文</p></blockquote><ul><li><a href="https://doc.vercel.app/frontend/" target="_blank" rel="noreferrer">极客时间的专栏在线免费</a> 涉及 数据结构、重学前端，Java 虚拟机等</li><li><a href="https://github.com/luohaha/Chinese-uvbook" target="_blank" rel="noreferrer">libuv中文教程</a></li><li><a href="https://github.com/tmallfe/tmallfe.github.io" target="_blank" rel="noreferrer">天猫前端博客</a> 看看 issue 博客内容，还是能学到不少知识的</li></ul><h2 id="项目推荐" tabindex="-1">项目推荐 <a class="header-anchor" href="#项目推荐" aria-label="Permalink to &quot;项目推荐&quot;">​</a></h2><blockquote><p>值得学习的项目</p></blockquote><ul><li><a href="https://github.com/ahwgs/react-gantt" target="_blank" rel="noreferrer">Gantt Component for React 类似 tapd 的甘特图</a> 甘特图组件，对应<a href="https://ahwgs.github.io/react-gantt/#/component" target="_blank" rel="noreferrer">文档</a></li><li><a href="https://github.com/ahwgs/fast_nest_temp" target="_blank" rel="noreferrer">Fast-nest-temp</a> Nest 实战</li></ul><h2 id="面经相关" tabindex="-1">面经相关 <a class="header-anchor" href="#面经相关" aria-label="Permalink to &quot;面经相关&quot;">​</a></h2><blockquote><p>八股文相关</p></blockquote><ul><li><a href="https://doc.vercel.app/frontend/" target="_blank" rel="noreferrer">极客时间的专栏在线免费</a> 涉及 数据结构、重学前端，Java 虚拟机、前端面经等</li><li><a href="https://github.com/whylisa/front-end-interview" target="_blank" rel="noreferrer">最强前端面试资源</a></li></ul>',30)]))}const b=r(n,[["render",i]]);export{d as __pageData,b as default};
